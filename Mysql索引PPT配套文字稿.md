## 时间复杂度

常数阶**O(1)**,对数阶**O(\**log\*2n\*\**),**线性阶**O(n),** 线性对数阶**O(\**n\**\**\*\*lo\*\*g\*2n\*\**),**平方阶**O(\*n\*2)，**立方阶**O(\*n\*3)**,...， k次方阶**O(\*n\*k),**指数阶**O(\*2\*n)。**随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

常见的算法时间复杂度由小到大依次为：

***\*Ο(1)＜Ο(log\*2n\*)＜Ο(n)＜Ο(nlog\*2n\*)＜Ο(\*n\*2)＜Ο(\*n\*3)＜…＜Ο(\*2\*n)＜Ο(n!)\****





前面的编号为PPT的第几页

## 带着问题思考索引

>1.索引为何使用B+Tree数据结构? 
>
>2.为什么需要 is_delete字段来标记是否删除. 
>直接物理删除数据对索引结构有什么样的影响?
>
>3.主键要设置为自动自增(AUTO_INCREMENT)?
>
>4.为什么频繁变化的数据,不适合作为索引字段?
> 
>
>5.为什么变化基数小(唯一性较差)字段,比如 status,type等字段. 
>不适合作为索引字段?



## 数据库数据存储方式

innoDB引擎的索引 是一个物理文件,索引和数据存储在一起的

mysaim引擎的索引是2个物理文件,索引和数据是分开的



## 从磁盘读取数据

表现形式为 Select 语句

查询语句的执行时间 取决于磁盘IO的次数. 次数越少,查询时间就越少.

磁盘的机械臂+旋转盘片的数据定位与读取方式，决定了它最突出的性能特点:擅长顺序读写，不善于随机I/O



## Linux文件系统预读功能

每一次IO时，不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据也加载到内存缓冲区中。

每次磁盘IO读取的数据我们称之为一页（page）

一页的数据大小为4K

一次磁盘IO操作可以取出物理存储中相邻的一大片数据，

如果查询的索引数据（就是从根节点一直到叶子节点整个过程中查询的节点数）都集中在该区域，

那么只需要一次磁盘IO，否则就需要多次磁盘IO



## 二叉查找树

特点: 比根节点小的在左边, 比跟节点大的在右边

但是这棵二叉树的查询效率就低了。

因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树



## 平衡二叉查找树

如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，

这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）

为了保持平衡,必须不断的对节点的位置进行旋转.

索引在旋转的过程中,会锁表.   



## 平衡多路查找树B Tree

单页大小16KB,系统一个磁盘块的存储空间往往没有这么大，只有4KB,

因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。

InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，

这将会减少磁盘I/O次数，提高查询效率。



## 聚集索引与非聚集索引

### 聚集索引

> 最后一级 叶子节点存储了数据

### 非聚集索引

> 最后一级 叶子节点并不是存储数据,而是存储的主键id.



## InnoDB存储引擎中的页

当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录 

从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，

InnoDB中页的大小一般为 **16** KB。

也就是在一般情况下，一次最少从磁 盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。 

File Header，表示页的一些通用信息，占固定的38字节。 

Page Header，表示数据页专有的一些信息，占固定的56个字节。 

Infimum + Supremum，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节。 

User Records：真实存储我们插入的记录的部分，大小不固定。 

Free Space：页中尚未使用的部分，大小不确定。 

Page Directory：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。 

File Trailer：用于检验页是否完整的部分，占用固定的8个字节  为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的LSN值，如果首部和尾部的校验和和LSN值校验不成功的话，就说明同步过程出现了 

问题。道InnoDB存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘 

中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计InnoDB的大叔们在每个页的尾部都加了一 

个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分： 

前4个字节代表页的校验和 

这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写 

完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File 

Trialer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。





\1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 

页内的记录是按照主键的大小顺序排成一个单向链表。 

各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。 

存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。 

\2. B+树的叶子节点存储的是完整的用户记录。 

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）



## BTree是最强的吗?

除传统的SQL引擎外，MongoDB，Hbase，Redis，谷歌的BigTable,这些新一代数据库，几乎都不使用BTree。新一代key-value store就更是很少使用BTree，

所以，BTree并不是当今数据库的主导数据结构。

### Btree的劣势

1.随机写入时，写放大严重，假定一个 BTree 节点保存了 100 条数据，如果我们修改了一条，那么当这个结点要写回磁盘 时，整个节点（对应的页）都要写回，

写放大就是 100 倍！

2.空间浪费严重，结点的空间的利用率一般低于 75%，







## SSD与机械硬盘比较

比起来，给BTree带来的有优势也有劣势。



## 赠与诸君

天将降大任于斯人也，必先  苦其心志，劳其筋骨，饿其体肤，空乏其身，

行拂乱其所为，所以动心忍性，曾益其所不能。

人恒过，然后能改，困于心，衡于虑，而后作；

征于色，发于声，而后喻。

然后知生于忧患而死于安乐也。